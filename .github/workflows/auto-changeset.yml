name: Auto Changeset

on:
  pull_request:
    branches:
      - main
    types: [opened, synchronize]

jobs:
  auto-changeset:
    name: Auto Changeset Check
    runs-on: ubuntu-latest
    # Skip this check for release PRs created by changesets
    if: ${{ !startsWith(github.head_ref, 'changeset-release/') }}
    permissions:
      contents: write
      pull-requests: write
      statuses: write
    steps:
      - name: Checkout Repo
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          ref: ${{ github.head_ref }}
          fetch-depth: 0

      - name: Setup Node.js 18
        uses: actions/setup-node@v4
        with:
          node-version: 18

      - name: Setup pnpm
        uses: pnpm/action-setup@v4

      - name: Install Dependencies
        run: pnpm install --frozen-lockfile

      - name: Check for new changesets in PR
        id: changeset_check
        run: |
          # Check if there are any NEW changeset files added by this PR
          NEW_CHANGESETS=$(git diff --name-only origin/main..HEAD | grep '^\.changeset/.*\.md$' | grep -v 'README.md' | wc -l)
          echo "new_changeset_count=$NEW_CHANGESETS" >> $GITHUB_OUTPUT

          if [ $NEW_CHANGESETS -eq 0 ]; then
            echo "needs_changeset=true" >> $GITHUB_OUTPUT
            echo "No new changesets found in this PR - will create one"
          else
            echo "needs_changeset=false" >> $GITHUB_OUTPUT
            echo "Found $NEW_CHANGESETS new changeset(s) in this PR"
          fi

      - name: Create automatic changeset
        if: steps.changeset_check.outputs.needs_changeset == 'true'
        env:
          PR_TITLE: ${{ github.event.pull_request.title }}
          PR_BODY: ${{ github.event.pull_request.body }}
        run: |
          # Configure git
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"

          # Generate a random changeset filename
          CHANGESET_ID=$(openssl rand -hex 8)

          # Use PR title + description for changeset message
          if [ -z "$PR_TITLE" ]; then
            PR_TITLE="Automatic patch release for PR changes"
          fi

          # Extract first paragraph (up to first blank line) and clean it up
          FIRST_PARAGRAPH=""
          if [ ! -z "$PR_BODY" ]; then
            FIRST_PARAGRAPH=$(echo "$PR_BODY" | sed '/^$/q' | head -3 | sed 's/^[[:space:]]*//;s/[[:space:]]*$//' | tr '\n' ' ' | sed 's/[[:space:]]\+/ /g')
          fi

          # Create changeset message - use title + description if available
          if [ ! -z "$FIRST_PARAGRAPH" ] && [ "$FIRST_PARAGRAPH" != "$PR_TITLE" ]; then
            CHANGESET_MESSAGE=$(printf "%s\n\n%s" "$PR_TITLE" "$FIRST_PARAGRAPH")
          else
            CHANGESET_MESSAGE="$PR_TITLE"
          fi

          # Detect which packages have changes
          CHANGED_FILES=$(git diff --name-only origin/main..HEAD)

          # Automatically detect all packages in packages/ directory
          PACKAGES=$(find packages -maxdepth 1 -type d -not -name "packages" -exec basename {} \; | sort)

          # Build array of changed packages
          CHANGED_PACKAGES=()

          for pkg in $PACKAGES; do
            if echo "$CHANGED_FILES" | grep -q "^packages/$pkg/"; then
              CHANGED_PACKAGES+=("$pkg")
            fi
          done

          # Log what we detected
          echo "Changed files in this PR:"
          echo "$CHANGED_FILES"
          echo ""
          echo "Available packages: $(echo $PACKAGES | tr '\n' ', ')"
          echo ""
          echo "Changed packages: ${CHANGED_PACKAGES[@]}"

          # Create changeset that bumps only changed packages
          {
            echo "---"
            for pkg in "${CHANGED_PACKAGES[@]}"; do
              echo "\"@uiid/$pkg\": patch"
            done
            echo "---"
            echo ""
            echo "$CHANGESET_MESSAGE"
          } > .changeset/${CHANGESET_ID}.md

          # Safeguard: if no packages were detected as changed, add all packages
          if [ ${#CHANGED_PACKAGES[@]} -eq 0 ]; then
            echo "Warning: No packages detected as changed. Adding all packages as fallback."
            {
              echo "---"
              for pkg in $PACKAGES; do
                echo "\"@uiid/$pkg\": patch"
              done
              echo "---"
              echo ""
              echo "$CHANGESET_MESSAGE"
            } > .changeset/${CHANGESET_ID}.md
          fi

          # Commit the changeset
          git add .changeset/${CHANGESET_ID}.md
          git commit -m "chore: add automatic changeset for PR"
          git push origin ${{ github.head_ref }}

          echo "Created and committed changeset: ${CHANGESET_ID}.md"
          echo ""
          echo "Final changeset content:"
          cat .changeset/${CHANGESET_ID}.md

      - name: Report completion status
        if: always()
        run: |
          if [ "${{ steps.changeset_check.outputs.needs_changeset }}" == "true" ]; then
            echo "âœ… Auto-changeset workflow completed: Created new changeset"
          else
            echo "âœ… Auto-changeset workflow completed: Existing changeset found, no action needed"
          fi
          echo "workflow_status=completed" >> $GITHUB_OUTPUT

      - name: Add comment to PR about changeset
        if: steps.changeset_check.outputs.needs_changeset == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const comment = `ðŸ¤– **Auto-changeset created!**

            This PR didn't have a changeset, so I've automatically created one based on the changes.

            The changeset has been added and committed to this PR. When this PR is merged, it will be included in the next release.

            If you'd like to customize the changeset description, you can edit the \`.changeset/*.md\` file that was created.`;

            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: comment
            });
