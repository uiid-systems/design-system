#!/usr/bin/env node

const fs = require("fs");
const path = require("path");

/**
 * Token Generator Utility
 *
 * Automatically converts W3C Design Token JSON files to CSS custom properties
 * with proper layer scoping and auto-generated comments.
 *
 * Features:
 * - Discovers all JSON files in packages/tokens/src/json/
 * - Maintains directory taxonomy (json/primitives/colors.json â†’ css/primitives/colors.css)
 * - Generates CSS with layer scoping
 * - Handles nested token structures
 * - Supports all W3C Design Token types
 */

class TokenGenerator {
  constructor() {
    this.tokensRoot = path.resolve(__dirname, "../packages/tokens/src");
    this.jsonDir = path.join(this.tokensRoot, "json");
    this.cssDir = path.join(this.tokensRoot, "css");
  }

  /**
   * Main execution function
   */
  async generate() {
    console.log("ðŸŽ¨ Generating CSS tokens from JSON...\n");

    try {
      // Ensure CSS directory exists
      this.ensureDirectoryExists(this.cssDir);

      // Discover all JSON token files
      const jsonFiles = this.discoverJsonFiles(this.jsonDir);

      if (jsonFiles.length === 0) {
        console.log("âš ï¸  No JSON token files found in", this.jsonDir);
        return;
      }

      // Process each JSON file
      for (const jsonFile of jsonFiles) {
        await this.processTokenFile(jsonFile);
      }

      console.log(
        `\nâœ… Successfully generated ${jsonFiles.length} CSS token file(s)`,
      );
    } catch (error) {
      console.error("âŒ Error generating tokens:", error.message);
      process.exit(1);
    }
  }

  /**
   * Recursively discover all JSON files in the tokens directory
   */
  discoverJsonFiles(dir, relativePath = "") {
    const files = [];

    if (!fs.existsSync(dir)) {
      return files;
    }

    const entries = fs.readdirSync(dir, { withFileTypes: true });

    for (const entry of entries) {
      const fullPath = path.join(dir, entry.name);
      const currentRelativePath = path.join(relativePath, entry.name);

      if (entry.isDirectory()) {
        // Recursively search subdirectories
        files.push(...this.discoverJsonFiles(fullPath, currentRelativePath));
      } else if (entry.isFile() && entry.name.endsWith(".tokens.json")) {
        files.push({
          fullPath,
          relativePath: currentRelativePath,
          name: path.parse(entry.name).name.replace(/\.tokens$/, ""),
        });
      }
    }

    return files;
  }

  /**
   * Process a single JSON token file
   */
  async processTokenFile(jsonFile) {
    console.log(`ðŸ“„ Processing: ${jsonFile.relativePath}`);

    try {
      // Read and parse JSON
      const jsonContent = fs.readFileSync(jsonFile.fullPath, "utf8");
      const tokens = JSON.parse(jsonContent);

      // Generate CSS content
      const cssContent = this.generateCssFromTokens(tokens, jsonFile);

      // Determine output path
      const cssRelativePath = jsonFile.relativePath.replace(
        /\.tokens\.json$/,
        ".tokens.css",
      );
      const cssFullPath = path.join(this.cssDir, cssRelativePath);

      // Ensure output directory exists
      this.ensureDirectoryExists(path.dirname(cssFullPath));

      // Write CSS file
      fs.writeFileSync(cssFullPath, cssContent, "utf8");

      console.log(
        `   \x1b[32mâœ“\x1b[0m Generated: \x1b[32mcss/${cssRelativePath}\x1b[0m`,
      );
    } catch (error) {
      console.error(
        `   \x1b[31mâŒ\x1b[0m Failed to process \x1b[31m${jsonFile.relativePath}\x1b[0m:`,
        error.message,
      );
      throw error;
    }
  }

  /**
   * Generate CSS content from parsed JSON tokens
   */
  generateCssFromTokens(tokens, jsonFile) {
    const { name, relativePath } = jsonFile;
    const layerName = this.generateLayerName(relativePath);

    // Generate header comment
    const header = this.generateHeader(tokens, name, relativePath);

    // Generate CSS custom properties
    const cssProperties = this.generateCssProperties(tokens);

    // Combine into final CSS
    return `${header}

@layer ${layerName} {
  :root {
${cssProperties.trimEnd()}
  }
}
`;
  }

  /**
   * Generate CSS header comment
   */
  generateHeader(tokens, fileName, relativePath) {
    const title = this.formatTitle(fileName);
    const description =
      tokens.$description || `${title} tokens for the UIID design system`;
    const timestamp = new Date().toISOString();

    return `/**
 * ${title} Tokens
 * ${description}
 * 
 * ðŸš¨ AUTO-GENERATED FILE - DO NOT EDIT DIRECTLY
 * 
 * Generated from: json/${relativePath}
 * Generated on: ${timestamp}
 * Generated by: scripts/generate-tokens.cjs
 */`;
  }

  /**
   * Generate CSS layer name from file path
   */
  generateLayerName(relativePath) {
    const parts = relativePath.replace(/\.tokens\.json$/, "").split(path.sep);
    return `uiid.tokens.${parts.join(".")}`;
  }

  /**
   * Format file name into a proper title
   */
  formatTitle(fileName) {
    return fileName
      .split(/[-_]/)
      .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
      .join(" ");
  }

  /**
   * Generate CSS custom properties from token object
   */
  generateCssProperties(tokens, prefix = "", indent = "    ") {
    let css = "";
    const entries = Object.entries(tokens).filter(
      ([key]) => !key.startsWith("$"),
    );

    for (let i = 0; i < entries.length; i++) {
      const [key, value] = entries[i];

      if (this.isTokenValue(value)) {
        // This is a token with a $value
        const cssVarName = this.generateCssVariableName(prefix, key);
        const cssValue = this.processCssValue(value.$value);
        css += `${indent}--${cssVarName}: ${cssValue};\n`;
      } else if (typeof value === "object" && value !== null) {
        // This is a nested object, recurse
        const newPrefix = prefix ? `${prefix}-${key}` : key;
        const nestedCss = this.generateCssProperties(value, newPrefix, indent);

        if (nestedCss) {
          css += nestedCss;

          // Add extra newline between top-level groups for readability
          if (!prefix && i < entries.length - 1) {
            css += "\n";
          }
        }
      }
    }

    return css;
  }

  /**
   * Check if an object is a design token (has $value property)
   */
  isTokenValue(obj) {
    return typeof obj === "object" && obj !== null && "$value" in obj;
  }

  /**
   * Generate CSS variable name from prefix and key
   */
  generateCssVariableName(prefix, key) {
    const parts = prefix ? [prefix, key] : [key];
    return parts.join("-");
  }

  /**
   * Process CSS value, handling references and transformations
   */
  processCssValue(value) {
    if (typeof value === "string") {
      // Handle token references like "{scale}"
      return value.replace(/\{([^}]+)\}/g, (match, tokenPath) => {
        // Convert token reference to CSS variable
        return `var(--${tokenPath.replace(/\./g, "-")})`;
      });
    }

    return String(value);
  }

  /**
   * Ensure directory exists, creating it if necessary
   */
  ensureDirectoryExists(dirPath) {
    if (!fs.existsSync(dirPath)) {
      fs.mkdirSync(dirPath, { recursive: true });
    }
  }
}

// Execute if run directly
if (require.main === module) {
  const generator = new TokenGenerator();
  generator.generate().catch(console.error);
}

module.exports = TokenGenerator;
